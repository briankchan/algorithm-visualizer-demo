/*
Now for our first non-trivial example, along with an introduction to *conditions*,
which can make it easier to define complex behaviors or scripted text.
*/
{
	"traceFile": "./trace.json",
	"frame": "av3_conditions.LinearSearch:linearSearch",
	"steps": [
		{"label": "check", "pause": true},
		{"label": "found", "pause": true},
		{"label": "notfound", "pause": true}
	],
	"views": [
		{
			// The `html` view type is just a <div> that holds child views.
			"type": "html",
			"height": 50,
			"position": "relative",
			"margin": "2em",
			"children": [ // These are the child views that produce the visible content.
				{
					"name": "array", // the numbers
					"type": "array",
					"array": {"expr": "arr"},
					"height": "100%",
					"elementConfig": {
						"color": "white",
						"fontSize": 20,

						/*
						Here, we see a basic application of conditions.

						Instead of using a ternary conditional operator
						(`boolean ? ifTrue : ifFalse`), we can separate the ifTrue
						value from the ifFalse value (the default).

						This also allows us to set multiple values using the same
						boolean check.
						E.g., try setting the fontSize of the current item to 30.
						*/
						"conditions": [
							{
								"if": {"expr": "i == self.index"},
								"then": {
									"color": "red"
								}
							}
						]
					}
				},
				{
					/*
					This view defines the rectangle around the current item.
					Feel free to skip to the last view; there's nothing important here.
					*/
					"name": "box",
					"type": "html",
					"position": "absolute", // (used to place over the numbers)
					"top": 0,
					"width": {"expr": "(100 / arr.length) + '%'"},
					"height": "100%",
					"border": "1px solid",
					// This view uses some special properties provided by the animation library.
					"xPercent": {"expr": "100 * (i ?? arr.length-1)"}, // (percent of own width)
					"autoAlpha": {"expr": "i !== undefined ? 1 : 0"}
				}
			]
		},

		{
			"name": "text",
			"type": "text",
			"conditions": [
				/*
				Conditions are also very useful for defining a "text box" that will be
				reused with different content across steps.
				*/
				{
					"if": {"expr": "inside(label, 'check') && !inside(label, 'found')"},
					"then": {"content": {"expr": "'currently checking index ' + i"}}
				},
				{
					"if": {"expr": "inside(label, 'found')"},
					"then": {"content": {"expr": "target + ' found at index ' + i"}}
				},
				{
					"if": {"expr": "inside(label, 'notfound')"},
					"then": {"content": {"expr": "target + ' not found'"}}
				}
			],
			/*
			This last line prevents `content` from becoming undefined
			on the last step (at the end of the method).
			*/
			"content": {"persist": true}
		}
	]
}
